<label>OpenAI API Key</label>
<input id="apiKey" type="password" placeholder="Wklej tutaj swój klucz (jeśli używasz bezpośrednio)" style="width:100%" />

<label>Model</label>
<select id="model">
	<option value="gpt-image-1" selected>gpt-image-1</option>
	<option value="gpt-image-1-mini">gpt-image-1-mini</option>
	<option value="dall-e-2">dall-e-2</option>
	<option value="dall-e-3">dall-e-3</option>
</select>

<label>Prompt</label>
<textarea id="prompt" placeholder="Napisz opis obrazu, np. 'A futuristic city at sunset, vibrant colors'"></textarea>

<label>Rozmiar</label>
<select id="size"></select>

<label>Jakość</label>
<select id="quality">
	<option value="standard">Standard</option>
	<option value="high">Wysoka (HD)</option>
</select>

<label>Liczba obrazów (1-10)</label>
<input id="n" type="number" min="1" max="10" value="1" />

<label><input id="useProxy" type="checkbox" /> Użyj serwera pośredniczącego (bez ujawniania klucza)</label>

<button id="generate">Generuj obraz</button>
<div id="status" class="small"></div>
<div id="results"></div>

<script>
const btn = document.getElementById('generate');
const statusEl = document.getElementById('status');
const resultsEl = document.getElementById('results');

const modelSelect = document.getElementById('model');
const sizeSelect = document.getElementById('size');
const qualitySelect = document.getElementById('quality');
const useProxyCheckbox = document.getElementById('useProxy');

const modelsConfig = {
	"gpt-image-1": {
		sizes: ['1024x1024','1536x1024','1024x1536'],
		qualities: ['standard','high']
	},
	"gpt-image-1-mini": {
		sizes: ['512x512','1024x1024'],
		qualities: ['standard']
	},
	"dall-e-2": {
		sizes: ['256x256','512x512','1024x1024'],
		qualities: ['standard']
	},
	"dall-e-3": {
		sizes: ['1024x1024','1792x1024','1024x1792'],
		qualities: ['standard','high']
	}
};

function updateSizeAndQuality() {
	const cfg = modelsConfig[modelSelect.value] || modelsConfig['gpt-image-1'];
	sizeSelect.innerHTML = '';
	cfg.sizes.forEach(s => {
		const o = document.createElement('option');
		o.value = s;
		o.textContent = s;
		sizeSelect.appendChild(o);
	});
	qualitySelect.innerHTML = '';
	cfg.qualities.forEach(q => {
		const o = document.createElement('option');
		o.value = q;
		o.textContent = q === 'high' ? 'Wysoka (HD)' : 'Standard';
		qualitySelect.appendChild(o);
	});
}

updateSizeAndQuality();
modelSelect.addEventListener('change', updateSizeAndQuality);

function clearResults() {
	resultsEl.innerHTML = '';
}

function createCard(imgSrc, filename, sourceUrl) {
	const card = document.createElement('div');
	card.className = 'card';
	const img = document.createElement('img');
	img.src = imgSrc;
	card.appendChild(img);

	const dl = document.createElement('a');
	dl.textContent = 'Pobierz';
	dl.style.display = 'inline-block';
	dl.style.marginRight = '8px';

	if (imgSrc.startsWith('data:') || sourceUrl === null) {
		dl.href = imgSrc;
		dl.download = filename;
	}
	else {
		dl.href = sourceUrl;
		dl.target = '_blank';
	}

	card.appendChild(dl);

	const view = document.createElement('a');
	view.textContent = 'Otwórz';
	view.style.marginLeft = '4px';
	view.href = imgSrc;
	view.target = '_blank';
	card.appendChild(view);

	return card;
}

btn.addEventListener('click', async () => {
	const apiKey = document.getElementById('apiKey').value.trim();
	const prompt = document.getElementById('prompt').value.trim();
	const model = modelSelect.value;
	const size = sizeSelect.value;
	const quality = qualitySelect.value;
	const n = Math.min(10, Math.max(1, parseInt(document.getElementById('n').value || '1')));
	const useProxy = useProxyCheckbox.checked;

	if (!prompt) {
		statusEl.textContent = 'Wpisz prompt.';
		return;
	}

	if (!useProxy && !apiKey) {
		statusEl.textContent = 'Wklej klucz OpenAI (lub włącz "Użyj serwera pośredniczącego").';
		return;
	}

	btn.disabled = true;
	statusEl.textContent = 'Wysyłam żądanie...';
	clearResults();

	try {
		let url;
		let fetchOptions;

		// Payload, możesz rozszerzyć o dodatkowe pola jeśli dany model je obsługuje
		const payload = {
			model: model,
			prompt: prompt,
			n: n,
			size: size,
			quality: quality
		};

		if (useProxy) {
			// Wyślij do twojego PHP proxy — on powinien trzymać klucz w ENV
			url = './generate-image.php';
			fetchOptions = {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(payload)
			};
		}
		else {
			// Bezpośrednie wywołanie OpenAI z kluczem w przeglądarce (niezalecane dla produkcji)
			url = 'https://api.openai.com/v1/images/generations';
			fetchOptions = {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					'Authorization': `Bearer ${apiKey}`
				},
				body: JSON.stringify(payload)
			};
		}

		const res = await fetch(url, fetchOptions);

		if (!res.ok) {
			const text = await res.text();
			throw new Error('Błąd API: ' + res.status + ' — ' + text);
		}

		const data = await res.json();

		// Obsługa możliwych formatów odpowiedzi: data[].b64_json lub data[].url
		const items = data.data || data.images || [];
		if (!Array.isArray(items) || items.length === 0) {
			// czasem proxy zwraca { images: [...] }
			if (Array.isArray(data.images)) {
				data.images.forEach((urlStr, idx) => {
					const filename = `openai_image_${Date.now()}_${idx+1}.png`;
					const card = createCard(urlStr, filename, urlStr);
					resultsEl.appendChild(card);
				});
				statusEl.textContent = 'Obrazy wygenerowane.';
				return;
			}
			throw new Error('Brak wygenerowanych danych w odpowiedzi.');
		}

		statusEl.textContent = 'Obrazy wygenerowane.';

		items.forEach((item, idx) => {
			let imgSrc = '';
			let sourceUrl = null;

			if (item.b64_json) {
				imgSrc = 'data:image/png;base64,' + item.b64_json;
			}
			else if (item.url) {
				imgSrc = item.url;
				sourceUrl = item.url;
			}
			else if (typeof item === 'string') {
				imgSrc = item;
				sourceUrl = item;
			}
			else {
				return;
			}

			const filename = `openai_image_${Date.now()}_${idx+1}.png`;
			const card = createCard(imgSrc, filename, sourceUrl);
			resultsEl.appendChild(card);
		});
	}
	catch (err) {
		console.error(err);
		statusEl.textContent = 'Błąd: ' + (err.message || err);
	}
	finally {
		btn.disabled = false;
	}
});
</script>